import { OpenAPIV3 } from 'openapi-types';
import { OpenAPIInternal } from '../types';

export class ZodGenerator {
  generate(doc: OpenAPIInternal): string {
    const lines: string[] = [
      '// Generated by PhnxGPT',
      "import { z } from 'zod';",
      ''
    ];

    if (doc.components && doc.components.schemas) {
      for (const [name, schema] of Object.entries(doc.components.schemas)) {
        lines.push(this.schemaToZod(name, schema as OpenAPIV3.SchemaObject));
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  private schemaToZod(name: string, schema: OpenAPIV3.SchemaObject): string {
    const lines: string[] = [];
    
    // Handle description as comment
    if (schema.description) {
      lines.push(`/** ${schema.description} */`);
    }

    const zodType = this.resolveZodType(schema);
    lines.push(`export const ${name}Schema = ${zodType};`);
    // Also export the inferred type for convenience
    lines.push(`export type ${name} = z.infer<typeof ${name}Schema>;`);

    return lines.join('\n');
  }

  private resolveZodType(schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject): string {
    if ('$ref' in schema) {
      const refParts = schema.$ref.split('/');
      const refName = refParts[refParts.length - 1];
      // Assuming schemas are in the same file for now. 
      // Using z.lazy to handle recursion or out-of-order definitions would be better for robust production,
      // but simple reference works for basic cases if ordered. 
      // For MVP safely, let's use z.lazy for refs to avoid "used before defined" errors.
      return `z.lazy(() => ${refName}Schema)`;
    }

    if (schema.type === 'object' || schema.properties) {
      let objectStr = 'z.object({';
      if (schema.properties) {
         const props: string[] = [];
         for (const [propName, propSchema] of Object.entries(schema.properties)) {
           const prop = propSchema as OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject;
           const isRequired = schema.required?.includes(propName);
           let propStr = `${propName}: ${this.resolveZodType(prop)}`;
           if (!isRequired) {
             propStr += '.optional()';
           }
           props.push(propStr);
         }
         objectStr += `\n  ${props.join(',\n  ')}\n`;
      }
      objectStr += '})';
      return objectStr;
    }

    if (schema.type === 'string') {
      if (schema.enum) {
        // z.enum expects a tuple of strings definition, which is tricky to generate dynamically as [string, ...string[]]
        // simpler to use z.union([z.literal('a'), z.literal('b')]) for general cases
        const enumValues = schema.enum.map(e => `z.literal('${e}')`);
        if (enumValues.length === 0) return 'z.string()';
        if (enumValues.length === 1) return enumValues[0];
        return `z.union([${enumValues.join(', ')}])`;
      }
      return 'z.string()';
    }

    if (schema.type === 'integer' || schema.type === 'number') return 'z.number()';
    if (schema.type === 'boolean') return 'z.boolean()';
    
    if (schema.type === 'array') {
      const items = schema.items as OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject;
      return `z.array(${this.resolveZodType(items)})`;
    }
    
    return 'z.any()';
  }
}
