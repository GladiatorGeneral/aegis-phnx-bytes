"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterfaceGenerator = void 0;
class InterfaceGenerator {
    generate(doc) {
        const lines = ['// Generated by PhnxGPT', ''];
        if (doc.components && doc.components.schemas) {
            for (const [name, schema] of Object.entries(doc.components.schemas)) {
                lines.push(this.schemaToInterface(name, schema));
                lines.push('');
            }
        }
        return lines.join('\n');
    }
    schemaToInterface(name, schema) {
        const lines = [];
        // Handle description
        if (schema.description) {
            lines.push(`/** ${schema.description} */`);
        }
        // Handle standard types
        if (schema.type === 'object' || schema.properties) {
            lines.push(`export interface ${name} {`);
            if (schema.properties) {
                for (const [propName, propSchema] of Object.entries(schema.properties)) {
                    const prop = propSchema;
                    const isRequired = schema.required?.includes(propName);
                    const typeStr = this.resolveType(prop);
                    lines.push(`  ${propName}${isRequired ? '' : '?'}: ${typeStr};`);
                }
            }
            lines.push('}');
        }
        else {
            // Aliases, Enums, etc.
            lines.push(`export type ${name} = ${this.resolveType(schema)};`);
        }
        return lines.join('\n');
    }
    resolveType(schema) {
        if ('$ref' in schema) {
            const refParts = schema.$ref.split('/');
            return refParts[refParts.length - 1];
        }
        if (schema.type === 'string') {
            if (schema.enum) {
                return schema.enum.map(e => `'${e}'`).join(' | ');
            }
            return 'string';
        }
        if (schema.type === 'integer' || schema.type === 'number')
            return 'number';
        if (schema.type === 'boolean')
            return 'boolean';
        if (schema.type === 'array') {
            const items = schema.items;
            return `${this.resolveType(items)}[]`;
        }
        return 'any';
    }
}
exports.InterfaceGenerator = InterfaceGenerator;
